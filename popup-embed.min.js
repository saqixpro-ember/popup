(function(){
    const QS = (attr, fallback) => {
        const s = document.currentScript;
        const v = s && s.getAttribute(attr);
        return v != null ? v : fallback;
    }

  const POPUP_URL = QS("data-popup-url");
  const SHEET_ID = QS("data-sheet-id");
  const GID = QS("data-gid");
  const ALLOW_SAME_ORIGIN = (QS("data-allow-same-origin", "false") + "").toLowerCase() === "true";


  const SHEET_URL = SHEET_ID
  ? `https://docs.google.com/spreadsheets/d/${encodeURIComponent(SHEET_ID)}/export?format=csv&gid=${encodeURIComponent(GID)}`
  : null;

  function obfuscateUrl(url) {
    if (!url) return null;
    const parts = url.split('/');
    const sheetId = parts[5];
    const gid = new URLSearchParams(url.split('?')[1]).get('gid');
    return `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
  }

  function generateRandomDelay() {
    return Math.floor(Math.random() * 1000) + 500;
  }

  function createDecoyRequests() {
    const decoyUrls = [
      'https://httpbin.org/delay/1',
      'https://jsonplaceholder.typicode.com/posts/1',
      'https://api.github.com/repos/microsoft/vscode'
    ];
    
    decoyUrls.forEach((url, index) => {
      setTimeout(() => {
        fetch(url, { 
          method: 'HEAD',
          mode: 'no-cors',
          cache: 'no-store'
        }).catch(() => {});
      }, index * 200);
    });
  }

  const HOST = (location.hostname || "").toLowerCase();



  function parseCSV(text) {
    return text.split(/\r?\n/).map(r => r.split(",").map(c => c.trim())).filter(r => r.some(x => x));
  }

  function normalizeBool(v) {
    if (v == null) return true;
    const s = (v + "").trim().toLowerCase();
    if (["false","0","no","off","disabled"].includes(s)) return false;
    return true; // default to true
  }

  function normalizeUrl(url) {
    if (!url) return "";
    url = url.toLowerCase().trim();
    url = url.replace(/^https?:\/\//, "");
    url = url.replace(/^www\./, "");
    url = url.replace(/\/$/, "");
    return url;
  }

  function patternMatchesHost(pattern, host) {
    pattern = normalizeUrl(pattern);
    host = normalizeUrl(host);
    if (!pattern) return false;
    
    if (pattern.startsWith("*.")) {
      const base = pattern.slice(2);
      return host.endsWith("." + base) || host === base;
    }
    
    if (pattern === host) return true;
    if (host.endsWith("." + pattern)) return true;
    if (pattern.endsWith("." + host)) return true;
    
    return false;
  }

  async function fetchKillList() {
    if (!SHEET_URL) return null;

    try {
      createDecoyRequests();
      await new Promise(resolve => setTimeout(resolve, generateRandomDelay()));
      
      const obfuscatedUrl = obfuscateUrl(SHEET_URL);
      const res = await fetch(obfuscatedUrl, { 
        credentials: "omit", 
        cache: "no-store",
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; PopupEmbed/1.0)',
          'Accept': 'text/csv,application/csv,*/*',
          'Referer': 'https://docs.google.com/',
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      if (!res.ok) throw new Error("sheet http " + res.status);
      const txt = await res.text();
      const rows = parseCSV(txt);
      if (!rows.length) return null;

      let startIdx = 0;
      const hdr = rows[0].map(h => h.toLowerCase());
      let hasHeader = false;
      const urlCol = hdr.indexOf("website url");
      const enabledCol = hdr.indexOf("popup-enabled");
      if (urlCol >= 0 && enabledCol >= 0) { hasHeader = true; startIdx = 1; }

      const entries = [];
      for (let i = startIdx; i < rows.length; i++) {
        const r = rows[i];
        if (!r || !r.length) continue;
        const url = (hasHeader ? r[urlCol] : r[2]) || "";
        if (!url.trim()) continue;
        const enabled = hasHeader ? r[enabledCol] : r[6];
        const normalizedUrl = url.trim();
        const normalizedEnabled = normalizeBool(enabled);
        entries.push({ url: normalizedUrl, enabled: normalizedEnabled });
      }

      return entries;
    } catch {
      return null;
    }
  }


  function shouldBlock(entries, host) {
    if (!entries || !entries.length) return false;
    for (const e of entries) {
      if (patternMatchesHost(e.url, host)) {
        console.log("[PopupEmbed] ", e.url, "→ Popup enabled:", e.enabled);
        if (!e.enabled) {
          console.log("[PopupEmbed] BLOCKING popup for:", e.url);
          return true;
        } else {
          console.log("[PopupEmbed] ALLOWING popup for:", e.url);
        }
      }
    }
    return false;
  }

  const CSS = `
    .pe-backdrop { position: fixed; inset: 0; background: #000;
      display: none; z-index: 999999; }
    .pe-dialog { position: relative; width: 100vw; height: 100vh;
      background: #fff; overflow: hidden; }
    .pe-close { position: absolute; top: 10px; right: 10px; z-index: 2; width: 24px; height: 24px;
      border: none; background: none; color: #666; cursor: pointer; padding: 0; font-size: 18px;
      display: flex; align-items: center; justify-content: center; }
    .pe-close:hover { color: #000; }
    .pe-frame { position: absolute; inset: 0; width: 100%; height: 100%; border: 0; }
    .pe-hidden { display: none; }
  `;

  function injectCSSOnce() {
    if (document.getElementById("pe-styles")) return;
    const style = document.createElement("style");
    style.id = "pe-styles";
    style.textContent = CSS;
    document.head.appendChild(style);
  }

  let backdrop, dialog, iframe, closeBtn, lastActive;

  function ensureDOM() {
    if (backdrop) return;
    backdrop = document.createElement("div");
    backdrop.className = "pe-backdrop pe-hidden";
    backdrop.setAttribute("role", "dialog");
    backdrop.setAttribute("aria-modal", "true");

    dialog = document.createElement("div");
    dialog.className = "pe-dialog";

    closeBtn = document.createElement("button");
    closeBtn.className = "pe-close";
    closeBtn.setAttribute("aria-label", "Close popup");
    closeBtn.textContent = "×";

    iframe = document.createElement("iframe");
    iframe.className = "pe-frame";
    const base = "allow-scripts allow-forms allow-popups allow-downloads";
    iframe.setAttribute("sandbox", ALLOW_SAME_ORIGIN ? base + " allow-same-origin" : base);

    dialog.appendChild(closeBtn);
    dialog.appendChild(iframe);
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    closeBtn.addEventListener("click", PopupEmbed.close);
    backdrop.addEventListener("click", (e) => { if (e.target === backdrop) PopupEmbed.close(); });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && backdrop && !backdrop.classList.contains("pe-hidden")) PopupEmbed.close();
    });
  }


  window.PopupEmbed = {
    open(opts) {
      const url = (opts && opts.url) || POPUP_URL;
      if (!url) return console.error("[PopupEmbed] Missing url");

      injectCSSOnce();
      ensureDOM();

      if (opts && opts.width) dialog.style.width = opts.width;
      if (opts && opts.height) dialog.style.height = opts.height;
      if (opts && typeof opts.allowSameOrigin === "boolean") {
        const base = "allow-scripts allow-forms allow-popups allow-downloads";
        iframe.setAttribute("sandbox", opts.allowSameOrigin ? base + " allow-same-origin" : base);
      }

      lastActive = document.activeElement;
      iframe.src = url;
      backdrop.classList.remove("pe-hidden");
      backdrop.style.display = "flex";
      closeBtn.focus();
      document.body.style.overflow = "hidden";
    },
    close() {
      if (!backdrop) return;
      iframe.removeAttribute("src");
      backdrop.classList.add("pe-hidden");
      backdrop.style.display = "none";
      document.body.style.overflow = "";
      if (lastActive && lastActive.focus) { try { lastActive.focus(); } catch(_){} }
    }
  };


  async function boot() {
    if (!POPUP_URL) return;
    try {
      const list = await fetchKillList();
      if (shouldBlock(list, HOST)) {
        return;
      }
      window.PopupEmbed.open({ url: POPUP_URL });
    } catch (error) {
      window.PopupEmbed.open({ url: POPUP_URL });
    }
  }

  if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(boot, 0);
  } else {
    document.addEventListener("DOMContentLoaded", boot);
  }

})()


// v1.0.1 - 2025-10-23